#06_inputs

# What if you want more detailed data from the client?
# HTTP has a format for representing extra data.
# It's like another way of representing dictionaries,
# with keys and values.
# How you give it to the server depends on the method you use.
# You might already have sent such kinds of data to the browser, through forms.
# Let's look at this server.

from http.server import HTTPServer, BaseHTTPRequestHandler

# The URLs for the paths for handling the inputs
# There are two common ways to handle them. One with GET, and one with POST.
GET_PATH = "get_handler"
POST_PATH = "post_handler"

class InputHandler(BaseHTTPRequestHandler):
	# This just generates HTML code for a single form, with a custom method.
	# You'll see it on the start page, where it's more clear.
	def __generate_form(self, action, method):
		message_fmt = """<!-- method says which method to use -->
<!-- action tells the client which path to go to when you submit the input -->
<!-- We'll also need to know the encoding,
     because the network just sees raw bytes. -->
<form action="/%(action)s" method="%(method)s" accept-charset="UTF-8">
<!-- Text input box. It has a name, so you know how to find the value. -->
First Name: <input type="text" name="first">
<br>Last Name: <input type="text" name="last">
<!-- Your form should always contain a submit button.
     It doesn't need a name, though. -->
<br><input type="submit">
</form>"""

		return message_fmt % {"action": action, "method": method}

	# This generates the main page, with a form for each method.
	# Just plain HTML, with a normal status.
	def __main(self):
		self.send_response(200)
		self.send_header("Content-Type", "text/html")
		self.end_headers()
		message_fmt = """<html>
<head><meta charset="UTF-8"><title>Generated By Python</title></head>
<body>
<h1>GET</h1>
%s
<h1>POST</h1>
%s
</body>
</html>"""

		message = message_fmt % (self.__generate_form(GET_PATH, "GET"),
					 self.__generate_form(POST_PATH,
							      "POST"))
		self.wfile.write(message.encode("UTF-8"))
	# To be helpful to the user, aways include a 404 message.
	def __handle_404(self):
		self.send_response(404)
		self.send_header("Content-Type", "text/html")
		self.end_headers()
		message = """<html>
<head><meta charset="UTF-8"><title>Path Not Found</title></head>
<body>
404 error
</body>
</html>"""
		self.wfile.write(message.encode("UTF-8"))

	def do_GET(self):
		# If you look at the URL after entering a form,
		# there is a question mark,
		# followed by some text that is not part of the action path.
		# That is the query string, and it contains the input.
		pure_path_end = self.path.find("?")
		if (pure_path_end >= 0):
			pure_path = self.path[1 : pure_path_end]
			query = self.path[pure_path_end + 1 :]
		else:
			pure_path = self.path[1 : ]
			query = ""
		if pure_path == "":
			# The default, which we'll see first.
			self.__main()
		elif pure_path == GET_PATH:
			self.__handle_get(query)
		else:
			self.__handle_404()

	# For GET, the input is just the query string,
	# after the question mark.
	# The hash and anything afterwards is not even sent to the server.
	def __handle_get(self, query):
		self.__handle_input(query)

	# We will handle all input strings the same way.
	def __handle_input(self, input_str):
		self.send_response(200)
		self.send_header("Content-Type", "text/html")
		self.end_headers()

		content_format = """<html>
<head><meta charset="UTF-8"><title>Generated By Python</title></head>
<body>
Path = %(path)s
<br>input_str = %(input)s
<br>Inputs:
%(formatted_inputs)s
</body>
</html>"""

		# So we got the input string.
		# You can kind of see that they
		# have pairs in the form [name]=[value],
		# separated by "&"
		# But what if I enter a weird character,
		# like another equals?
		# Luckily, that gets encoded.
		# How do we decode all of it?
		# We use parse_qs from urllib.parse
		from urllib.parse import parse_qs
		query_data = parse_qs(input_str)
		formatted_inputs = ""
		# We get a dictionary, and we can show the name-value pairs.
		# Actually, each value is a list of values,
		# in case you repeated the name.
		# Before we just display the user's options directly,
		# what happens if I entered something that looks like HTML?
		# That is what's called cross side scripting,
		# and if I put in something with Javascript,
		# I can cause a lot of damage.
		# To avoid that, you use this function, escape
		from cgi import escape
		for (name, values) in query_data.items():
			for value in values:
				formatted_inputs += \
				"<br>%s: %s" % (escape(name), escape(value))
		message = content_format % {"path": self.path,
					    "input": input_str,
					    "formatted_inputs":
					    formatted_inputs}
		self.wfile.write(message.encode("UTF-8"))

	# But wait, there's another, kind of better, way to handle inputs.
	# It's the POST method. You can handle this with do_POST.
	# This time, the data is not in the URL. So the path looks clean.
	# That's also good because, for example,
	# somebody looking at you browser history
	# can't find the password that you used.
	def do_POST(self):
		pure_path = self.path[1 : ]
		if pure_path == POST_PATH:
			self.__handle_post()
		else:
			self.__handle_404()

	# The issue is, how much should you read?
	# Normal files have an end that you can tell right away.
	# But if you're getting messages through the network,
	# you might have to wait a while.
	# There's a header for that.
	def __handle_post(self):
		# To read a header, use get from the headers field.
		content_len_str = self.headers.get("Content-Length")
		# Check if the input is bad, and send the 400 code
		# for bad requests, if it is.
		if len(content_len_str) == 0 or not content_len_str.isdigit():
			self.send_response(400)
			self.end_headers()
			return
		# We have a file of raw bytes.
		raw_content = self.rfile.read(int(content_len_str))
		# We also need to convert it to a string.
		self.__handle_input(raw_content.decode("UTF-8"))

# HTTPServer again.
server = HTTPServer(("", 8080), InputHandler)
server.serve_forever()
